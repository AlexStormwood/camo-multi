import {
    isValidType,
    isEmptyValue,
    isInChoices,
    isArray,
    isEmbeddedDocument,
    isNumber,
    isDate, ValidationError
} from './validate.js';
import {getClientInstance as DB, isNativeId} from './client.js';
import {
    COLLECTION_NAME, IS_BASE_DOCUMENT, IS_EMBEDDED,
    SCHEMA_1PROP_KEYS, SCHEMA_ALL_KEYS,
    SCHEMA_ARRAY_KEYS,
    SCHEMA_IS_EMBED_ARRAY, SCHEMA_REF_1_KEYS,
    SCHEMA_REF_EMBD_KEYS,
    SCHEMA_REF_N_KEYS
} from './symbols.js';
import {generateSchemaForDocument} from './schema.js';



/**
 * @typedef {Object} CamoPopulateTarget
 * @property {BaseDocument[]|string[]} ref1DocsAndProps - like [doc1, 'foo', doc2, 'bar', ...]
 * @property {(BaseDocument|string)[]} refNDocsAndProps - as above, but foo and bar are array properties of doc1/doc2
 */

/**
 * @type {Map<typeof BaseDocument, Object.<string, CamoPopulateTarget>>}
 */
let docClassToIdPopTargetMap = new Map();

/** @typeof {Map<typeof BaseDocument, Object>} */
const schemaByDocClass = new Map();

let isBaseSchemaIdMissing = true;

/**
 * @abstract
 */
export class BaseDocument {

    constructor() {
        this._id = null;
        
        if (isBaseSchemaIdMissing) {
            BaseDocument.prototype._schema._id = {type: DB().nativeIdType()};
            isBaseSchemaIdMissing = false;
        }
    }

    /**
     * Get current collection name.
     * The name is autogenerated by the lowercase class' name with an 's' appended. 
     * Can be overridden individually by derived classes.
     * 
     * @returns {String}
     */
    static collectionName() {
        let name = this[COLLECTION_NAME];
        if (!name) {
            name = this.name.toLowerCase() + 's';
            this.prototype[COLLECTION_NAME] = name;
            this[COLLECTION_NAME] = name;
        }
        return name;
    }
    
    /**
     * @return {String}
     * @final
     */
    collectionName() {
        return this[COLLECTION_NAME] || this.constructor.collectionName();
    }

    /**
     * set schema
     * @param {Object} extension
     */
    schema(extension) {
        if (!extension || typeof extension !== 'object') {
            return;
        }
        for (const key of Object.keys(extension)) {
            if (key[0] === '_' || key === 'toString') {
                throw new Error(`Forbidden schema key name "${key}"`);
            }
            this[key] = extension[key];
        }
    }

    /*
     * Pre/post Hooks
     *
     * To add a hook, the extending class just needs
     * to override the appropriate hook method below.
     */

    preValidate() {
    }
    
    postValidate() {
    }
    
    preSave() {
    }
    
    /** 
     * @return {Promise<Document>}
     */
    save() {
    }
    
    postSave() {
    }

    preDelete() {
    }
    
    postDelete() {
    }


    /**
     * Get default value
     *
     * @param {String} schemaKey Key of current schema
     * @returns {*}
     */
    _getDefaultValueForKey(schemaKey) {
        if (schemaKey === '_id') {
            return null;
        }
        let defaultForKey = this._schema[schemaKey]?.default;
        return (typeof defaultForKey === 'function') ? defaultForKey() : defaultForKey;
    }
    
    
    /**
     * Validate current document
     *
     * The method throw errors if document has invalid value
     *
     * TODO: This is not the right approach. The method needs to collect all
     * errors in array and return them.
     */
    validate() {
        for (const key of Object.keys(this._schema)) {
            let value = this[key];

            // TODO: This should probably be in Document, not BaseDocument
            if (value !== null && value !== undefined) {
                if (value[IS_EMBEDDED]) {
                    value.validate();
                    continue;
                } 
                if (isArray(value) && value.length && value[0][IS_EMBEDDED]) {
                    value.forEach(v => v && v.validate());
                    continue;
                }
            }

            let keyEntry = this._schema[key],
                keyType = keyEntry.type;
            
            if (!isValidType(value, keyType)) {
                // TODO: Formatting should probably be done somewhere else
                let typeName = null,
                    valueName = null,
                    isArrayType = Array.isArray(keyType);
                
                if (isArrayType && keyType.length > 0) {
                    typeName = '[' + keyType[0].name + ']';
                } else if (isArrayType && keyType.length === 0) {
                    typeName = '[]';
                } else {
                    typeName = keyType.name;
                }

                if (Array.isArray(value)) {
                    // TODO: Not descriptive enough! Strings can look like numbers
                    try {
                        valueName = '[' + value.toString() + ']'; // prototype-less array items will throw
                    } catch (err) {
                        valueName = `[${value.map(v => typeof v).join(',')}]`;
                    }
                } else {
                    valueName = typeof value;
                }
                throw new ValidationError('Value assigned to ' + this.collectionName() + '.' + key +
                    ' should be ' + typeName + ', got ' + valueName);
            }

            if (keyEntry.required && isEmptyValue(value)) {
                throw new ValidationError('Key ' + this.collectionName() + '.' + key +
                    ' is required' + ', but got ' + value);
            }

            if (keyEntry.match && typeof value === 'string' && !keyEntry.match.test(value)) {
                throw new ValidationError('Value assigned to ' + this.collectionName() + '.' + key +
                    ' does not match the regex/string ' + keyEntry.match.toString() + '. Value was ' + value);
            }

            if (!isInChoices(keyEntry.choices, value)) {
                throw new ValidationError('Value assigned to ' + this.collectionName() + '.' + key +
                    ' should be in choices [' + keyEntry.choices.join(', ') + '], got ' + value);
            }

            if (isNumber(keyEntry.min) && value < keyEntry.min) {
                throw new ValidationError('Value assigned to ' + this.collectionName() + '.' + key +
                    ' is less than min, ' + keyEntry.min + ', got ' + value);
            }

            if (isNumber(keyEntry.max) && value > keyEntry.max) {
                throw new ValidationError('Value assigned to ' + this.collectionName() + '.' + key +
                    ' is less than max, ' + keyEntry.max + ', got ' + value);
            }

            if (typeof keyEntry.validate === 'function' && !keyEntry.validate(value)) {
                throw new ValidationError('Value assigned to ' + this.collectionName() + '.' + key +
                    ' failed custom validator. Value was ' + value);
            }
        }
    }

    /*
     * Right now this only canonicalizes dates (integer timestamps
     * get converted to Date objects), but maybe we should do the
     * same for strings (UTF, Unicode, ASCII, etc)?
     * TODO think about cached schema array (behind symbol) of date-key candidates incl. embedded/embedded[]
     */
    canonicalize() {
        const schema = this._schema;
        for (const key of schema[SCHEMA_ALL_KEYS]) {
            let value = this[key];

            if (schema[key].type === Date && isDate(value)) {
                this[key] = new Date(value);
            } else if (value && value[IS_EMBEDDED]) {
                value.canonicalize(); // TODO: This should probably be in Document, not BaseDocument
            }
        }
    }

    /** @internal */
    _createIndexesOnce() {
    }
    
    /**
     * Create new document from data
     *
     * @param {Object} [data]
     * @returns {BaseDocument}
     */
    static create(data) {
        if (data !== undefined) {
            return this._fromData(data);
        }
        return this._instantiate();
    }

    /**
     * Create new document from self.
     * If no schema was created for this (sub)class yet, 
     * it will be created ONCE and cached in the prototype,
     * so we never generate a schema twice.
     *
     * @returns {BaseDocument}
     */
    static _instantiate() {
        let instance = new this(),
            schema = schemaByDocClass.get(this);
        
        if (!schema) {
            schema = generateSchemaForDocument(instance);
            schemaByDocClass.set(this, schema);
            this.prototype._schema = schema;
            instance._createIndexesOnce();
            // console.log('Generated schema for %s, total schemas: %s; schema: %s', this.name, schemaByDocClass.size, schema);
        }
        
        // apply schema default values
        for (const key of schema[SCHEMA_ARRAY_KEYS]) {
            instance[key] = instance._getDefaultValueForKey(key) || [];
        }
        for (const key of schema[SCHEMA_1PROP_KEYS]) {
            instance[key] = instance._getDefaultValueForKey(key);
        }
        
        return instance;
    }

    /**
     * @param {Object|Object[]} data - raw POJO(s) to create documents for
     * @return {BaseDocument|BaseDocument[]}
     */
    static _fromData(data) {
        let docs = [];
        
        for (const obj of isArray(data) ? data : [data]) {
            let instance = this._instantiate(),
                schema = instance._schema;
            
            for (const key of Object.keys(obj)) {
                let objVal = obj[key];
                
                if (!schema[key]) {
                    instance[key] = objVal; // If its not in the schema, we don't care about it... right?
                    continue; 
                }
                
                let newVal = (objVal === null) ? instance._getDefaultValueForKey(key) : objVal,
                    schemaType = schema[key].type;

                if (schemaType[IS_EMBEDDED]) {
                    // Initialize EmbeddedDocument
                    instance[key] = schemaType._fromData(newVal);
                } else if (schema[key][SCHEMA_IS_EMBED_ARRAY]) {
                    // Initialize array of EmbeddedDocuments
                    instance[key] = newVal.map(v => schemaType[0]._fromData(v));
                } else {
                    // Initialize primitive or array of primitives
                    instance[key] = newVal;
                }
            }

            docs.push(instance);
        }

        return (docs.length === 1) ? docs[0] : docs;
    }

    populate() {
        return BaseDocument.populate(this);
    }

    /**
     * Populates document references
     *
     * TODO : EMBEDDED
     * @param {BaseDocument[]|BaseDocument} docOrDocs
     * @param {?Array} [fields] if an array, only the contained field names will be populated  
     * @returns {Promise}
     */
    static populate(docOrDocs, fields) {
        if (!docOrDocs) {
            return Promise.resolve([]);
        }
        /** @type {BaseDocument[]} */
        let documents = isArray(docOrDocs) ? docOrDocs : [docOrDocs];
        if (!documents.length) {
            return Promise.resolve([]);
        }

        // Load all 1-level-deep references, Find all unique keys needed to be loaded...

        //  Assumption here: all documents in the database will have the same schema
        let firstSchema = documents[0]._schema,
            useFields = fields && Array.isArray(fields) && fields.length;

        docClassToIdPopTargetMap.clear();

        // Handle multi-reference keys (example schema: { myDocs: [MyDocumentClass] })
        for (const key of firstSchema[SCHEMA_REF_N_KEYS]) {
            if (useFields && fields.indexOf(key) < 0) {
                continue;
            }
            for (const doc of documents) {
                let referencedIds = doc[key];
                if (isArray(referencedIds) && referencedIds.length) {

                    let referencedDocClass = firstSchema[key].type[0],
                        id2popTarget = docClassToIdPopTargetMap.get(referencedDocClass);

                    if (!id2popTarget) {
                        docClassToIdPopTargetMap.set(referencedDocClass, id2popTarget = Object.create(null));
                    }
                    for (const id of referencedIds) {
                        if (id2popTarget[id]) {
                            id2popTarget[id].refNDocsAndProps.push(doc, key);
                        } else {
                            id2popTarget[id] = {
                                refNDocsAndProps: [doc, key],
                                ref1DocsAndProps: []
                            };
                        }
                    }
                    doc[key] = [];  // flush the ids -> referenced values are pushed in later instead 
                }
            }
        }

        // Handle single reference keys (example schema: { myDoc: MyDocumentClass })
        for (const key of firstSchema[SCHEMA_REF_1_KEYS]) {
            if (useFields && fields.indexOf(key) < 0) {
                continue;
            }
            for (const doc of documents) {
                let referencedId = doc[key];
                if (referencedId && isNativeId(referencedId)) {
                    let referencedDocClass = firstSchema[key].type,
                        id2popTarget = docClassToIdPopTargetMap.get(referencedDocClass);

                    if (!id2popTarget) {
                        docClassToIdPopTargetMap.set(referencedDocClass, id2popTarget = Object.create(null));
                    }
                    if (id2popTarget[referencedId]) {
                        id2popTarget[referencedId].ref1DocsAndProps.push(doc, key);
                    } else {
                        id2popTarget[referencedId] = {
                            refNDocsAndProps: [],
                            ref1DocsAndProps: [doc, key]
                        };
                    }
                }
            }
        }

        let loadPromises = [];

        for (const [docClass, id2popTarget] of docClassToIdPopTargetMap.entries()) {
             loadPromises.push(docClass.find({_id: {$in: Object.keys(id2popTarget)}}, {populate: false}).then(foundDocs => {
                 for (const foundDoc of foundDocs) {
                     let {ref1DocsAndProps, refNDocsAndProps} = id2popTarget[foundDoc._id];
                     for (let i = 0, len = ref1DocsAndProps.length; i < len; i++) {
                         let targetDoc = ref1DocsAndProps[i],
                             targetProp = ref1DocsAndProps[++i];
                         targetDoc[targetProp] = foundDoc;
                     }
                     for (let i = 0, len = refNDocsAndProps.length; i < len; i++) {
                         let targetDoc = refNDocsAndProps[i],
                             targetProp = refNDocsAndProps[++i];
                         targetDoc[targetProp].push(foundDoc);
                     }
                 }
             }));
        }

        // ...and finally execute all promises and return our fully loaded documents.
        return Promise.all(loadPromises).then(() => docOrDocs);
    }

    /**
     * For JSON.stringify
     *
     * @returns {*}
     * @override
     */
    toJSON() {
        let obj = this._toData(true),
            schema = this._schema;
        
        for (const key of schema[SCHEMA_ALL_KEYS]) {
            let val = obj[key];
            if (schema[key].private) {
                delete obj[key];
            } else if (val && val.toJSON) {
                obj[key] = val.toJSON();
            } else if (isArray(val)) {
                obj[key] = val.map(v => v && v.toJSON ? v.toJSON() : v);
            }
        }
        return obj;
    }

    /**
     * TODO shouldn't this adhere strictly to the schema, i.e. iterate all schema keys and pick whats needed
     *  instead of iterating all the doc's keys, even those that are not in the schema? 
     * @param {boolean} [keepId] 
     * @returns {Object}
     */
    _toData(keepId) {
        let dataObj = Object.create(null);
        
        for (const key of Object.keys(this)) {
            let val = this[key];
            if (key[0] === '_') {
                if (key !== '_id' || !keepId) {
                    continue;
                }
                dataObj[key] = val;
            } else if (isEmbeddedDocument(val)) {
                dataObj[key] = val._toData();
            } else if (isArray(val) && val.length && isEmbeddedDocument(val[0])) {
                dataObj[key] = val.map(v => v._toData());
            } else {
                dataObj[key] = val;
            }
        }
        return dataObj;
    }

    /**
     * @return {EmbeddedDocument[]} - may contain nullish values
     */
    _getEmbeddeds() {
        let embeddeds = [];
        for (const key of this._schema[SCHEMA_REF_EMBD_KEYS]) {
            let emb = this[key];
            if (isArray(emb)) {
                embeddeds.push(...emb);
            } else {
                embeddeds.push(emb);
            }
        }
        return embeddeds.filter(o => !!o);
    }

    /**
     * Returns for a given hook name an array of 
     * all promises of this document AND all its embedded documents.
     * 
     * @param {string} hookName
     * @param {boolean} [asPromise] - if true, returns not an Array, but a Promise pending to fulfill all found hook promises if any 
     * @return {Promise[]|Promise<*>}
     * @internal
     */
    _getHookPromises(hookName, asPromise) {
        let hookPromises = [];
        for (const doc of [this, ...this._getEmbeddeds()]){
            if (!doc[hookName]) {
                continue; // most likely case frequently
            }
            let hookFn = doc[hookName];
            if (typeof hookFn !== 'function') {
                throw new Error(`Hook ${hookName} of a ${doc.collectionName()} is not a function`);
            }
            let promise = hookFn.apply(doc); 
            if (promise && promise instanceof Promise) {
                hookPromises.push(promise);
            }
        }
        if (asPromise) {
            return (hookPromises.length) ? Promise.all(hookPromises) : Promise.resolve();
        }
        return hookPromises;
    }

    /** @deprecated */
    get id() {
        throw new Error('Document.id - use Document._id instead');
    }

    /** @deprecated */
    set id(x) {
        throw new Error('Document.id - use Document._id instead');
    }
}

BaseDocument.prototype._schema = Object.create(null);

BaseDocument[IS_BASE_DOCUMENT] = true;
BaseDocument.prototype[IS_BASE_DOCUMENT] = true;
