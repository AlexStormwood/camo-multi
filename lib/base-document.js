import _ from 'lodash';
import {
    isSupportedType,
    isValidType,
    isEmptyValue,
    isInChoices,
    isArray,
    isEmbeddedDocument,
    isNumber,
    isDate, IS_BASE_DOCUMENT, IS_EMBEDDED, IS_DOCUMENT
} from './validate.js';
import {getClientInstance as DB, isNativeId} from './client.js';
import {ValidationError} from './errors.js';
import {hasOwnProp} from './util.js';

const SCHEMA_REF_1_KEYS = Symbol('s_ref1');
const SCHEMA_REF_N_KEYS = Symbol('s_refN');
const SCHEMA_REF_EMBD_KEYS = Symbol('s_ref');
const SCHEMA_ARRAY_KEYS = Symbol('s_arr');
const SCHEMA_1PROP_KEYS = Symbol('s_1');
const IS_EMBED_ARRAY_TYPE = Symbol('s_Embed[]');

const COLLECTION_NAME = Symbol('collName');

/**
 * @typedef {Object} CamoPopulateTarget
 * @property {BaseDocument[]|string[]} ref1DocsAndProps - like [doc1, 'foo', doc2, 'bar', ...]
 * @property {(BaseDocument|string)[]} refNDocsAndProps - as above, but foo and bar are array properties of doc1/doc2
 */

/**
 * @type {Map<typeof BaseDocument, Object.<string, CamoPopulateTarget>>}
 */
let docClassToIdPopTargetMap = new Map();

/** @typeof {Map<typeof BaseDocument, Object>} */
const schemaByDocClass = new Map();

let isBaseSchemaIdMissing = true;

/**
 * @abstract
 */
export class BaseDocument {

    constructor() {
        this._id = null;
        
        if (isBaseSchemaIdMissing) {
            BaseDocument.prototype._schema._id = {type: DB().nativeIdType()};
            isBaseSchemaIdMissing = false;
        }
    }

    /**
     * Get current collection name.
     * The name is autogenerated by the lowercase class' name with an 's' appended. 
     * Can be overridden individually by derived classes.
     * 
     * @returns {String}
     */
    static collectionName() {
        let name = this[COLLECTION_NAME];
        if (!name) {
            name = this.name.toLowerCase() + 's';
            this.prototype[COLLECTION_NAME] = name;
            this[COLLECTION_NAME] = name;
        }
        return name;
    }
    
    /**
     * @return {String}
     * @final
     */
    collectionName() {
        return this[COLLECTION_NAME] || this.constructor.collectionName();
    }

    /**
     * set schema
     * @param {Object} extension
     */
    schema(extension) {
        if (!extension || typeof extension !== 'object') {
            return;
        }
        for (const key of Object.keys(extension)) {
            if (key[0] === '_' || key === 'toString') {
                throw new Error(`Forbidden schema key name "${key}"`);
            }
            this[key] = extension[key];
        }
    }

    /*
     * Pre/post Hooks
     *
     * To add a hook, the extending class just needs
     * to override the appropriate hook method below.
     */

    preValidate() {
    }
    
    postValidate() {
    }
    
    preSave() {
    }
    
    /** 
     * @return {Promise<Document>}
     */
    save() {
    }
    
    postSave() {
    }

    preDelete() {
    }
    
    postDelete() {
    }

    /**
     * Generate a schema for this instance.
     * @return {Object}
     */
    _generateSchema() {
        // Assumption: schemas of Document subclasses are immutable at runtime, so it should be safe to use a  
        //             shallow copy of the next best _schema off the prototype chain
        let schema = Object.create(null);
        for (const key of Object.keys(this._schema)) {
            schema[key] = this._schema[key];
        }

        /** @type {string[]} - keys which reference 1 Document-type entity */
        schema[SCHEMA_REF_1_KEYS] = [];
        /** @type {string[]} - keys which reference arrays of Document-type entities */
        schema[SCHEMA_REF_N_KEYS] = [];
        /** @type {string[]} - keys which reference single or arrays of Embedded-type entities */
        schema[SCHEMA_REF_EMBD_KEYS] = [];
        /** @type {string[]} - keys of array properties */
        schema[SCHEMA_ARRAY_KEYS] = [];
        /** @type {string[]} - keys of non-array properties */
        schema[SCHEMA_1PROP_KEYS] = [];
        
        for (const key of Object.keys(this)) {
            if (key[0] === '_') {
                continue; // ignore private variables
            }

            let isEmbeddedArrayType = false;
            
            // Normalize the type format
            let propVal = this[key];
            if (propVal.type) {
                schema[key] = propVal;
            } else if (isSupportedType(propVal)) {
                schema[key] = {type: propVal};
            } else {
                throw new Error(`Unsupported type or bad variable. Remember, non-persisted objects must start with an underscore (_). Got: ${propVal}`);
            }

            let schemaType = schema[key].type;

            // Assign a default if needed
            if (isArray(schemaType)) {
                schema[SCHEMA_ARRAY_KEYS].push(key);
                if (schemaType[0]?.[IS_DOCUMENT]) {
                    schema[SCHEMA_REF_N_KEYS].push(key);
                } else if (schemaType[0]?.[IS_EMBEDDED]) {
                    schema[SCHEMA_REF_EMBD_KEYS].push(key);
                    isEmbeddedArrayType = true;
                }
            } else {
                schema[SCHEMA_1PROP_KEYS].push(key);
                if (schemaType[IS_DOCUMENT]) {
                    schema[SCHEMA_REF_1_KEYS].push(key);
                } else if (schemaType[IS_EMBEDDED]) {
                    schema[SCHEMA_REF_EMBD_KEYS].push(key);
                }
            }
            
            /** attaching embed-array info to each entry in the schema, as it's frequently looked up in {@link _fromData()} */  
            schema[key][IS_EMBED_ARRAY_TYPE] = isEmbeddedArrayType; 
        }
        return schema;
    }

    /**
     * Get default value
     *
     * @param {String} schemaKey Key of current schema
     * @returns {*}
     */
    _getDefaultValueForKey(schemaKey) {
        if (schemaKey === '_id') {
            return null;
        }
        let defaultForKey = this._schema[schemaKey]?.default;
        return (typeof defaultForKey === 'function') ? defaultForKey() : defaultForKey;
    }
    
    
    /**
     * Validate current document
     *
     * The method throw errors if document has invalid value
     *
     * TODO: This is not the right approach. The method needs to collect all
     * errors in array and return them.
     */
    validate() {
        const that = this;

        _.keys(that._schema).forEach(function (key) {
            let value = that[key];

            // TODO: This should probably be in Document, not BaseDocument
            if (value !== null && value !== undefined) {
                if (value[IS_EMBEDDED]) {
                    value.validate();
                    return;
                } 
                if (isArray(value) && value.length && value[0][IS_EMBEDDED]) {
                    value.forEach(v => v && v.validate());
                    return;
                }
            }

            if (!isValidType(value, that._schema[key].type)) {
                // TODO: Formatting should probably be done somewhere else
                let typeName = null;
                let valueName = null;
                if (Array.isArray(that._schema[key].type) && that._schema[key].type.length > 0) {
                    typeName = '[' + that._schema[key].type[0].name + ']';
                } else if (Array.isArray(that._schema[key].type) && that._schema[key].type.length === 0) {
                    typeName = '[]';
                } else {
                    typeName = that._schema[key].type.name;
                }

                if (Array.isArray(value)) {
                    // TODO: Not descriptive enough! Strings can look like numbers
                    try {
                        valueName = '[' + value.toString() + ']'; // prototype-less array items will throw
                    } catch (err) {
                        valueName = `[${value.map(v => typeof v).join(',')}]`;
                    }
                } else {
                    valueName = typeof value;
                }
                throw new ValidationError('Value assigned to ' + that.collectionName() + '.' + key +
                    ' should be ' + typeName + ', got ' + valueName);
            }

            if (that._schema[key].required && isEmptyValue(value)) {
                throw new ValidationError('Key ' + that.collectionName() + '.' + key +
                    ' is required' + ', but got ' + value);
            }

            if (that._schema[key].match && typeof value === 'string' && !that._schema[key].match.test(value)) {
                throw new ValidationError('Value assigned to ' + that.collectionName() + '.' + key +
                    ' does not match the regex/string ' + that._schema[key].match.toString() + '. Value was ' + value);
            }

            if (!isInChoices(that._schema[key].choices, value)) {
                throw new ValidationError('Value assigned to ' + that.collectionName() + '.' + key +
                    ' should be in choices [' + that._schema[key].choices.join(', ') + '], got ' + value);
            }

            if (isNumber(that._schema[key].min) && value < that._schema[key].min) {
                throw new ValidationError('Value assigned to ' + that.collectionName() + '.' + key +
                    ' is less than min, ' + that._schema[key].min + ', got ' + value);
            }

            if (isNumber(that._schema[key].max) && value > that._schema[key].max) {
                throw new ValidationError('Value assigned to ' + that.collectionName() + '.' + key +
                    ' is less than max, ' + that._schema[key].max + ', got ' + value);
            }

            if (typeof that._schema[key].validate === 'function' && !that._schema[key].validate(value)) {
                throw new ValidationError('Value assigned to ' + that.collectionName() + '.' + key +
                    ' failed custom validator. Value was ' + value);
            }
        });
    }

    /*
     * Right now this only canonicalizes dates (integer timestamps
     * get converted to Date objects), but maybe we should do the
     * same for strings (UTF, Unicode, ASCII, etc)?
     */
    canonicalize() {
        const that = this;

        _.keys(that._schema).forEach(function (key) {
            let value = that[key];

            if (that._schema[key].type === Date && isDate(value)) {
                that[key] = new Date(value);
            } else if (value && value[IS_EMBEDDED]) {
                // TODO: This should probably be in Document, not BaseDocument
                value.canonicalize();
                return; // TODO superfluous or falsely meant as 'break'? check later
            }
        });
    }

    /**
     * @type {?function}
     */
    static _createIndexesOnce = null;
    
    /**
     * Create new document from data
     *
     * @param {Object} [data]
     * @returns {BaseDocument}
     */
    static create(data) {
        if (this._createIndexesOnce) {
            this._createIndexesOnce();
        }
        
        if (data !== undefined) {
            return this._fromData(data);
        }
        return this._instantiate();
    }

    /**
     * Create new document from self.
     * If no schema was created for this (sub)class yet, 
     * it will be created ONCE and cached in the prototype,
     * so we never generate a schema twice.
     *
     * @returns {BaseDocument}
     */
    static _instantiate() {
        let instance = new this(),
            schema = schemaByDocClass.get(this);
        
        if (!schema) {
            schema = instance._generateSchema();
            schemaByDocClass.set(this, schema);
            this.prototype._schema = schema;
            // console.log('Generated schema for %s, total schemas: %s; schema: %s', this.name, schemaByDocClass.size, schema);
        }
        
        // apply schema default values
        for (const key of schema[SCHEMA_ARRAY_KEYS]) {
            instance[key] = instance._getDefaultValueForKey(key) || [];
        }
        for (const key of schema[SCHEMA_1PROP_KEYS]) {
            instance[key] = instance._getDefaultValueForKey(key);
        }
        
        return instance;
    }

    /**
     * @param {Object|Object[]} data - raw POJO(s) to create documents for
     * @return {BaseDocument|BaseDocument[]}
     */
    static _fromData(data) {
        let docs = [];
        
        for (const obj of isArray(data) ? data : [data]) {
            let instance = this._instantiate(),
                schema = instance._schema;
            
            for (const key of Object.keys(obj)) {
                let objVal = obj[key];
                
                if (!schema[key]) {
                    instance[key] = objVal; // If its not in the schema, we don't care about it... right?
                    continue; 
                }
                
                let newVal = (objVal === null) ? instance._getDefaultValueForKey(key) : objVal,
                    schemaType = schema[key].type;

                if (schemaType[IS_EMBEDDED]) {
                    // Initialize EmbeddedDocument
                    instance[key] = schemaType._fromData(newVal);
                } else if (schema[key][IS_EMBED_ARRAY_TYPE]) {
                    // Initialize array of EmbeddedDocuments
                    instance[key] = newVal.map(v => schemaType[0]._fromData(v));
                } else {
                    // Initialize primitive or array of primitives
                    instance[key] = newVal;
                }
            }

            docs.push(instance);
        }

        return (docs.length === 1) ? docs[0] : docs;
    }

    populate() {
        return BaseDocument.populate(this);
    }

    /**
     * Populates document references
     *
     * TODO : EMBEDDED
     * @param {BaseDocument[]|BaseDocument} docOrDocs
     * @param {Array} [fields]
     * @returns {Promise}
     */
    static populate(docOrDocs, fields) {
        if (!docOrDocs) {
            return Promise.resolve([]);
        }
        /** @type {BaseDocument[]} */
        let documents = isArray(docOrDocs) ? docOrDocs : [docOrDocs];
        if (!documents.length) {
            return Promise.resolve([]);
        }

        // Load all 1-level-deep references, Find all unique keys needed to be loaded...

        //  Assumption here: all documents in the database will have the same schema
        let firstSchema = documents[0]._schema,
            useFields = fields && Array.isArray(fields) && fields.length;

        docClassToIdPopTargetMap.clear();

        // Handle multi-reference keys (example schema: { myDocs: [MyDocumentClass] })
        for (const key of firstSchema[SCHEMA_REF_N_KEYS]) {
            if (useFields && fields.indexOf(key) < 0) {
                continue;
            }
            for (const doc of documents) {
                let referencedIds = doc[key];
                if (isArray(referencedIds) && referencedIds.length) {

                    let referencedDocClass = firstSchema[key].type[0],
                        id2popTarget = docClassToIdPopTargetMap.get(referencedDocClass);

                    if (!id2popTarget) {
                        docClassToIdPopTargetMap.set(referencedDocClass, id2popTarget = Object.create(null));
                    }
                    for (const id of referencedIds) {
                        if (id2popTarget[id]) {
                            id2popTarget[id].refNDocsAndProps.push(doc, key);
                        } else {
                            id2popTarget[id] = {
                                refNDocsAndProps: [doc, key],
                                ref1DocsAndProps: []
                            };
                        }
                    }
                    doc[key] = [];  // flush the ids -> referenced values are pushed in later instead 
                }
            }
        }

        // Handle single reference keys (example schema: { myDoc: MyDocumentClass })
        for (const key of firstSchema[SCHEMA_REF_1_KEYS]) {
            if (useFields && fields.indexOf(key) < 0) {
                continue;
            }
            for (const doc of documents) {
                let referencedId = doc[key];
                if (referencedId && isNativeId(referencedId)) {
                    let referencedDocClass = firstSchema[key].type,
                        id2popTarget = docClassToIdPopTargetMap.get(referencedDocClass);

                    if (!id2popTarget) {
                        docClassToIdPopTargetMap.set(referencedDocClass, id2popTarget = Object.create(null));
                    }
                    if (id2popTarget[referencedId]) {
                        id2popTarget[referencedId].ref1DocsAndProps.push(doc, key);
                    } else {
                        id2popTarget[referencedId] = {
                            refNDocsAndProps: [],
                            ref1DocsAndProps: [doc, key]
                        };
                    }
                }
            }
        }

        let loadPromises = [];

        for (const [docClass, id2popTarget] of docClassToIdPopTargetMap.entries()) {
             loadPromises.push(docClass.find({_id: {$in: Object.keys(id2popTarget)}}, {populate: false}).then(foundDocs => {
                 for (const foundDoc of foundDocs) {
                     let {ref1DocsAndProps, refNDocsAndProps} = id2popTarget[foundDoc._id];
                     for (let i = 0, len = ref1DocsAndProps.length; i < len; i++) {
                         let targetDoc = ref1DocsAndProps[i],
                             targetProp = ref1DocsAndProps[++i];
                         targetDoc[targetProp] = foundDoc;
                     }
                     for (let i = 0, len = refNDocsAndProps.length; i < len; i++) {
                         let targetDoc = refNDocsAndProps[i],
                             targetProp = refNDocsAndProps[++i];
                         targetDoc[targetProp].push(foundDoc);
                     }
                 }
             }));
        }

        // ...and finally execute all promises and return our fully loaded documents.
        return Promise.all(loadPromises).then(() => docOrDocs);
    }

    /**
     * For JSON.Stringify
     *
     * @returns {*}
     */
    toJSON() {
        let values = this._toData({_id: true});
        let schema = this._schema;
        for (let key in schema) {
            if (hasOwnProp(schema, key)) {
                if (schema[key].private) {
                    delete values[key];
                } else if (values[key] && values[key].toJSON) {
                    values[key] = values[key].toJSON();
                } else if (isArray(values[key])) {
                    let newArray = [];
                    values[key].forEach(function (i) {
                        if (i && i.toJSON) {
                            newArray.push(i.toJSON());
                        } else {
                            newArray.push(i);
                        }
                    });
                    values[key] = newArray;
                }
            }
        }

        return values;
    }

    /**
     * TODO refactor
     * @param {?Object} [keep]
     * @returns {{}}
     * @private
     */
    _toData(keep) {
        if (keep === undefined || keep === null) {
            keep = {};
        } else if (keep._id === undefined) {
            keep._id = true;
        }

        let values = {};
        for (const key of Object.keys(this)) {
            if (key[0] === '_') {
                if (key !== '_id' || !keep._id) {
                    continue;
                }
                values[key] = this[key];
            } else if (isEmbeddedDocument(this[key])) {
                values[key] = this[key]._toData();
            } else if (isArray(this[key]) && this[key].length > 0 && isEmbeddedDocument(this[key][0])) {
                values[key] = [];
                this[key].forEach(function (v) {
                    values[key].push(v._toData());
                });
            } else {
                values[key] = this[key];
            }
        }

        return values;
    }

    /**
     * @return {EmbeddedDocument[]}
     */
    _getEmbeddeds() {
        let embeddeds = [];
        for (const key of this._schema[SCHEMA_REF_EMBD_KEYS]) {
            embeddeds = embeddeds.concat(this[key]);
        }
        return embeddeds.filter(o => !!o);
    }

    _getHookPromises(hookName) {
        let embeddeds = this._getEmbeddeds();

        let hookPromises = [];
        hookPromises = hookPromises.concat(_.invokeMap(embeddeds, hookName));
        hookPromises.push(this[hookName]());
        return hookPromises;
    }

    get id() {
        throw new Error('Document.id - use Document._id instead');
    }

    set id(x) {
        throw new Error('Document.id - use Document._id instead');
    }
}

BaseDocument.prototype._schema = Object.create(null);

BaseDocument[IS_BASE_DOCUMENT] = true;
BaseDocument.prototype[IS_BASE_DOCUMENT] = true;
